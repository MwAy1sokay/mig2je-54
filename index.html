<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<link rel="manifest" href="/site.webmanifest" />
<meta charset="UTF-8">
<title>Mattmusikspelaresajt 1.42</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<!-- üéµ google font for a bit of flair -->
<link href="https://fonts.googleapis.com/css2?family=Overpass:wght@400;600&display=swap" rel="stylesheet">

<style>
:root {
  --bg: #000;
  --panel: #111;
  --border: #333;
  --text: #fffcfc;
  --accent: #00877c;
  --accent-soft: #00cfbe;
  --gap: .65rem;
}

*{box-sizing:border-box}

body{
  font-family:"Overpass",Arial,Helvetica,sans-serif;
  background:var(--bg);
  color:var(--text);
  margin:0 auto;
  max-width:720px;
  padding:1.25rem;
  line-height:1.45;
}

h1{
  text-align:center;
  margin:0 0 1.3rem;
  font-weight:600;
  letter-spacing:.03em;
}

a,button,input,select{
  font-family:inherit;
  font-size:1rem;
  color:inherit;
}

/* generic inputs */
input[type="text"],
input[type="range"],
select{
  background:var(--panel);
  border:1px solid var(--border);
  color:var(--text);
  border-radius:4px;
}

input[type="text"],
select{
  padding:.5rem .6rem;
}

button{
  padding:.5rem 1.35rem;
  background:var(--accent);
  border:none;
  border-radius:4px;
  color:#fff;
  cursor:pointer;
  transition:background .15s,transform .15s;
}

button:disabled{opacity:.35;cursor:default}
button:not(:disabled):hover{background:var(--accent-soft)}
button:not(:disabled):active{transform:scale(.97)}

button:focus-visible,
input:focus-visible,
select:focus-visible{
  outline:2px solid var(--accent);
  outline-offset:2px
}

#nowPlaying{
  display:flex;
  align-items:center;
  gap:.75rem;
  flex-wrap:nowrap
}
#nowTitle{
  flex:1 1 auto;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis
}
/* responsive video square */
#videoWrap{
  position: relative;
  flex:0 0 auto;
  width:clamp(48px,18vw,80px);
  aspect-ratio:1/1;
  border-radius:6px;
  overflow:hidden;
  background:#000
}
#videoWrap #player{width:100%;height:100%;pointer-events:none}

.controls{
  display:flex;
  align-items:center;
  gap:var(--gap);
  flex-wrap:wrap;
  margin-top:1.05rem
}
.controls button{flex:0 0 auto}

.controls button{
  padding:.25rem .6rem;
  font-size:1.2rem;
}
#time{
  font-variant-numeric:tabular-nums;
  opacity:.8;
}
@media(max-width:600px){
  #time{flex:1 1 100%;text-align:left;margin-top:.25rem}
}
#progress{
  flex:1 1 100%;
  margin-top:.45rem;
  height:7px;
  appearance:none;
  background:var(--border);
  border-radius:4px
}
#progress::-webkit-slider-thumb{
  appearance:none;
  width:14px;
  height:14px;
  border-radius:50%;
  background:var(--accent);
  border:0;
  cursor:pointer;
  margin-top:-3.5px
}

h2{margin:1.6rem 0 .7rem}

#queueWrap{
  max-height:50vh;
  overflow:auto;
  border:1px solid var(--border);
  border-radius:6px;
  background:var(--panel)
}

#queue li{
  display:flex;
  align-items:center;
  gap:.45rem;
  padding:.55rem .65rem;
  border-bottom:1px solid var(--border);
  transition:background .15s
}
#queue li:last-child{border-bottom:none}
#queue li span.title{flex:1;cursor:pointer;user-select:none}
#queue li:hover{background:#181818}
#queue li button{padding:.25rem .7rem}
#queue li img.thumb{
  width:48px;               /* ‚¨ÖÔ∏è  choose any size you like */
  height:48px;              /*    keep the same to stay square  */
  flex:0 0 auto;
  object-fit:cover;         /* crop left & right, keep centre  */
  object-position:center;
  border-radius:4px;        /* (optional) rounded corners      */
}


.playlist-controls{
  margin-top:1.8rem;
  padding:1rem;
  border:1px solid var(--border);
  border-radius:6px;
  background:var(--panel)
}
.playlist-controls h3{margin:0 0 .8rem;font-weight:600}
.playlist-controls button,label{margin-top:.5rem;margin-right:.7rem}
.playlist-controls input[type="file"]{display:none}

@media(max-width:600px){
  .controls button{flex:1 1 46%}
  #progress{flex:1 1 100%}
  #queue li button{padding:.3rem .75rem}
}

/* ensure dark theme everywhere */
input[type="text"],select{
  background-color:var(--panel)!important;
  color:var(--text)!important;
  border:1px solid var(--border);
  border-radius:4px
}
input:-webkit-autofill{
  background-color:var(--panel)!important;
  color:var(--text)!important;
  box-shadow:0 0 0 1000px var(--panel) inset!important;
  -webkit-text-fill-color:var(--text)!important
}
input#videoId,
input#playlistName{
  width:100%
}

/* layout tweaks for the two horizontal bars */
.search-bar{
  display:flex;
  flex-wrap:wrap;
  gap:var(--gap)
}
.search-bar input{
  flex:1 1 12rem;
  width:auto   /* override any 100% */
}
.search-bar button{flex:0 0 auto
}
.search-bar + .search-bar{
  margin-top: var(--gap);   /* ‚âà0.65 rem ‚Äì adjust if you want more/less */
}
.drag-handle{
  cursor:grab;
  font-size:1.1rem;
  line-height:1;
  padding:0 .25rem;
  user-select:none;
  opacity:.7;
}
li.sortable-chosen .drag-handle{cursor:grabbing;opacity:1;}

#addBtn{margin-bottom:1rem}

#nowTitle{font-size:1.15rem}
#nowTitle small{font-size:.9em;opacity:.7}
/* buffering overlay */
#buffering{
  position:absolute;
  inset:0;                     /* full cover */
  display:none;                /* toggled in JS */
  place-content:center;        /* center spinner */
  backdrop-filter:blur(2px);   /* subtle glass */
}

/* simple ring spinner */
#buffering::after{
  content:'';
  width:32px;height:32px;
  border:4px solid #fff3;
  border-top-color:#fff;
  border-radius:50%;
  animation:spin .8s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<h1>Mattmusikspelaresajt 1.42</h1>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Search official audio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="search-bar">
  <input id="artistInput" type="text" placeholder="Artist name">
  <input id="songInput"   type="text" placeholder="Song title">
  <button id="searchBtn">Search & Play</button>
</div>

<div class="search-bar">
  <input id="videoId" type="text" placeholder="YouTube video ID">
  <button id="addBtn">Add & Play</button>
</div>

<div id="nowPlaying">
  <div id="videoWrap">
    <div id="player" allow="autoplay; picture-in-picture"></div>
    <div id="buffering" aria-hidden="true"></div>
  </div>
  <span id="nowTitle"></span>
</div>

<div class="controls">
  <button id="prev" title="Previous">‚èÆ</button>
  <button id="playPause" title="Play / Pause">‚ñ∂</button>
  <button id="skip" title="Next">‚è≠</button>

  <span id="time" style="min-width:5.5rem;text-align:center">0:00 / 0:00</span>

  <input type="range" id="progress" min="0" max="100" value="0">
</div>

<h2>Music Queue</h2>
<div id="queueWrap"><ul id="queue"></ul></div>

<div class="playlist-controls">
  <h3>Playlists</h3>
  <input id="playlistName" placeholder="New playlist name">
  <button id="savePlaylist">Save Playlist</button><br><br>
  <select id="playlistSelect"><option value="">‚Äî Load playlist ‚Äî</option></select>
  <button id="deletePlaylist">Delete</button><br><br>
  <button id="exportPlaylist">Export</button>
  <label>Import <input type="file" id="importFile" accept=".json"></label>
</div>

<!-- ==========  SCRIPT  ========== -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
/* ---------- state ---------- */
let queue=[],currentIdx=-1;
let player,playerReady=false,pendingPlay=null;


const qEl=document.getElementById('queue');
new Sortable(qEl,{
  handle: '.drag-handle',
  animation:150,
  onEnd: e => {
    queue.splice(e.newIndex,0, queue.splice(e.oldIndex,1)[0]);
    saveQueue();
  }
});
const nowBox    =document.getElementById('nowPlaying'),nowT=document.getElementById('nowTitle');
const playBtn   =document.getElementById('playPause');
const prevBtn   =document.getElementById('prev');
const timeLabel =document.getElementById('time');
const progress  =document.getElementById('progress');
const buffering =document.getElementById('buffering');
let   vidDuration = 0; 

/* ---------- persistence ---------- */
const loadQueue=()=>{const m=document.cookie.match(/(?:^|;\\s*)queue=([^;]+)/);
                     queue=m?JSON.parse(decodeURIComponent(m[1])):[];};
const saveQueue=()=>document.cookie='queue='+encodeURIComponent(JSON.stringify(queue))+
                                ';max-age=31536000;path=/';

/* ---------- playlists ---------- */
const LS='playlists',sel=document.getElementById('playlistSelect');
const getLists=()=>JSON.parse(localStorage.getItem(LS)||'{}');
const setLists=o=>localStorage.setItem(LS,JSON.stringify(o));
const refreshSel=()=>{sel.innerHTML='<option value="">‚Äî Load playlist ‚Äî</option>';
  Object.keys(getLists()).sort().forEach(n=>sel.insertAdjacentHTML('beforeend',`<option>${n}</option>`));};
/* ---------- YouTube ---------- */
function onYouTubeIframeAPIReady(){
  player=new YT.Player('player',{
    height:'225',width:'400',
    playerVars:{controls:0,playsinline:1},
    events:{
      onReady:()=>{playerReady=true;setTiny();if(pendingPlay!==null){playIdx(pendingPlay);pendingPlay=null;}},
      onStateChange:e=>{
        if(e.data===0) skip();
        if(e.data===1) setTiny();
        playBtn.textContent = (e.data === 1) ? '‚è∏' : '‚ñ∂';
        buffering.style.display = (e.data === 3) ? 'grid' : 'none';
      }
    }
  });
}
const setTiny=()=>{try{player.setPlaybackQuality('tiny');}catch{}};

/* ---------- helpers ---------- */
/* fetch {title, artist} via noembed */
const fetchVideoInfo = async id => {
  try {
    const r = await fetch(`https://noembed.com/embed?url=https://youtu.be/${id}`);
    const j = await r.json();
    const rawArtist = j.author_name || '';               // e.g. "Imagine Dragons ‚Äì Topic"
    const artist = rawArtist.replace(/\s*[‚Äì-]\s*Topic\s*$/i, ''); // strip dash+Topic
    return { title: j.title || id, artist };
  } catch {
    return { title: id, artist: '' };
  }
};

/* ------------------------------------------------------------------
   one-time migration: add artist to legacy queue items
------------------------------------------------------------------ */
async function backfillArtists () {
  const tasks = queue.map(async (it, idx) => {
    if (it.artist) return;                       // already has artist
    try {
      const info = await fetchVideoInfo(it.id);  // same helper you use on add
      queue[idx].artist = info.artist;           // keep existing title
    } catch { /* ignore failures */ }
  });
  await Promise.all(tasks);
  saveQueue();           // write updated cookie / localStorage
  renderQueue();         // show new ‚Äú‚Äî Artist‚Äù labels
  updateNow(queue[currentIdx]);
}
/* ---------- DragHandle ---------- */
const renderQueue = () => {
  qEl.innerHTML = '';
  queue.forEach((it,i) => qEl.insertAdjacentHTML('beforeend', `
    <li>
      <span class="drag-handle" aria-hidden="true">‚â°</span>
      <img class="thumb" loading="lazy"
           src="https://i.ytimg.com/vi/${encodeURIComponent(it.id)}/mqdefault.jpg" alt="">
      <span class="title">
        ${it.title || it.id}
        ${it.artist ? `<small style="opacity:.7"> ‚Äî ${it.artist}</small>` : ''}
      </span>
      <button data-del="${i}">‚úï</button>
    </li>`));
};
/* ---------- helpers ---------- */
const updateNow = it => {
  if (!it) {
    nowBox.style.display = 'none';
    return;
  }
  nowT.innerHTML = it.title + (it.artist ? ` <small>‚Äî ${it.artist}</small>` : '');
  nowBox.style.display = 'flex';        // <‚Äî use flex, not block
};
/* ---------- playback ---------- */
function playIdx (i) {
  if (!queue.length || i < 0 || i >= queue.length) return;
  if (!playerReady) { pendingPlay = i; updateNow(queue[i]); return; }
  currentIdx = i;
  player.loadVideoById(queue[i].id);
  setTiny();
  updateNow(queue[i]);
  vidDuration = 0;                               // reset cache
  timeLabel.textContent = '0:00 / ‚Ä¶';            // placeholder
  waitForDuration();                             // ‚Üê NEW (see helper below)
}
const skip=()=>{if(queue.length)playIdx((currentIdx+1)%queue.length);};
/* ---------- UI ---------- */
document.getElementById('addBtn').addEventListener('click',async()=>{
  const id=document.getElementById('videoId').value.trim();if(!id)return;
  const info = await fetchVideoInfo(id);queue.unshift({ id, title: info.title, artist: info.artist });
  saveQueue();renderQueue();playIdx(0);document.getElementById('videoId').value='';
});
playBtn.addEventListener('click',()=>{if(!playerReady)return;
  (player.getPlayerState()===1)?player.pauseVideo():player.playVideo();});
document.getElementById('skip').addEventListener('click',skip);
prevBtn.addEventListener('click', () => {
  if (!queue.length) return;
  const back = (currentIdx - 1 + queue.length) % queue.length;
  playIdx(back);
});
progress.addEventListener('input', function () {
  if (!playerReady || !vidDuration) return;
  const newTime = vidDuration * this.value / 100;
  player.seekTo(newTime, true);
  timeLabel.textContent =
        formatTime(newTime) + ' / ' + formatTime(vidDuration);
});
const formatTime = s => {
  const m   = Math.floor(s / 60);
  const sec = Math.floor(s % 60).toString().padStart(2,'0');
  return m + ':' + sec;
};
setInterval(() => {
  if (!playerReady || !player.getDuration) return;

  const dur = player.getDuration();
  if (dur) vidDuration = dur;     // cache once it‚Äôs known
  if (!vidDuration)   return;     // still zero ‚Äì wait for next tick

  const cur = player.getCurrentTime();
  progress.value    = (cur / vidDuration) * 100;
  timeLabel.textContent =
        formatTime(cur) + ' / ' + formatTime(vidDuration);

}, 1000);
function waitForDuration () {
  const probe = setInterval(() => {
    const d = player.getDuration();
    if (d) {
      vidDuration = d;
      timeLabel.textContent = '0:00 / ' + formatTime(d);
      clearInterval(probe);                      // stop polling
    }
  }, 200);                                       // check every 0.2 s

  setTimeout(() => clearInterval(probe), 4000);  // safety: quit after 4 s
}
qEl.addEventListener('click',e=>{
const { del } = e.target.dataset;
if (del) {
queue.splice(del, 1);
if (currentIdx >= del) currentIdx--;
}
  else if(e.target.classList.contains('title')){
    playIdx([...qEl.children].indexOf(e.target.parentElement));return;
  } else return;
  renderQueue();saveQueue();
});

/* playlists */
document.getElementById('savePlaylist').addEventListener('click',()=>{
  const n=document.getElementById('playlistName').value.trim();
  if(!n||!queue.length)return;const l=getLists();l[n]=queue;setLists(l);
  refreshSel();alert('Playlist saved!');
});
sel.addEventListener('change',function(){
  if(!this.value)return;queue=[...getLists()[this.value]];
  renderQueue();saveQueue();playIdx(0);
});
document.getElementById('deletePlaylist').addEventListener('click',()=>{
  if(!sel.value)return;const l=getLists();delete l[sel.value];setLists(l);
  refreshSel();sel.value='';
});

/* export / import */
document.getElementById('exportPlaylist').addEventListener('click',()=>{
  const chosen=sel.value;let data,name;
  if(chosen){data=getLists()[chosen];name=chosen;}
  else{if(!queue.length){alert('Nothing to export');return;}
       data=queue;name='CurrentQueue';}
  const blob=new Blob([JSON.stringify({name,data})],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  Object.assign(document.createElement('a'),{href:url,download:name+'.json'}).click();
  URL.revokeObjectURL(url);
});
document.getElementById('importFile').addEventListener('change', function () {
  const f = this.files[0]; if (!f) return;
  const r = new FileReader();
  r.onload = async e => {                                  // üÜï make handler async
    try {
      const o = JSON.parse(e.target.result);
      if (!o.name || !Array.isArray(o.data)) throw 'bad';

      /* ----------  back-fill artist on imported items ---------- */
      for (const it of o.data) {
        if (!it.artist) {                                   // missing artist?
          const info = await fetchVideoInfo(it.id);         // reuse helper
          it.artist = info.artist;
        }
      }                                                     // üÜï end back-fill loop

      const l = getLists(); l[o.name] = o.data; setLists(l);
      refreshSel(); alert('Imported ‚Äú‚Äò' + o.name + '‚Äù playlist!');
    } catch { alert('Invalid playlist file'); }
  };
  r.readAsText(f); this.value = '';
});
/* ----------  search & add official audio ---------- */
const YT_KEY = 'AIzaSyCtBUhn0t1AeiHivsdmw4ro5thw6R7Ijio';

async function searchOfficialAudio (artist, song) {
  // Build search string the way YouTube Music labels tracks
  const q = `${song} "Provided to YouTube by" ${artist}`;
  const url = `https://www.googleapis.com/youtube/v3/search?` +
              new URLSearchParams({
                key: YT_KEY,
                part: 'snippet',
                type: 'video',
                maxResults: 10,
                videoCategoryId: 10,      // üé∂ Music only
                q
              });

  const r  = await fetch(url);
  const j  = await r.json();
  if (!j.items?.length) return null;

  // 1) exact Topic-channel match
  const topicRE = new RegExp(`^${artist}\\s*-\\s*Topic$`, 'i');
  let hit = j.items.find(v => topicRE.test(v.snippet.channelTitle));

  // 2) fallback: keep first result but verify description has the phrase
  if (!hit) hit = j.items[0];
  const vid = hit.id.videoId;

  // optional second call to confirm ‚ÄúProvided to YouTube by‚Äù
  const vr = await fetch(`https://www.googleapis.com/youtube/v3/videos?` +
                         new URLSearchParams({
                           key: YT_KEY,
                           part: 'snippet',
                           id: vid
                         }));
  const vd = await vr.json();
  const good = vd.items?.[0]?.snippet?.description
                 ?.toLowerCase().includes('provided to youtube by');

  return good ? hit : null;
}

/* UI hook */
document.getElementById('searchBtn').addEventListener('click', async () => {
  const artist = document.getElementById('artistInput').value.trim();
  const song   = document.getElementById('songInput').value.trim();
  if (!artist || !song) { alert('Type both artist and song'); return; }

  try {
    const hit = await searchOfficialAudio(artist, song);
    if (!hit) { alert('No official audio found üòï'); return; }

    // ‚îÄ‚îÄ NEW: derive canonical artist name ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const chanTitle   = hit.snippet.channelTitle || artist;
    const cleanArtist = chanTitle.replace(/\s*-\s*Topic\s*$/i, '').trim();

    queue.unshift({
      id:    hit.id.videoId,
      title: hit.snippet.title,
      artist: cleanArtist       // use the cleaned-up value
    });
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    saveQueue();
    renderQueue();
    playIdx(0);
    document.getElementById('artistInput').value = '';
    document.getElementById('songInput').value   = '';
  } catch (err) {
    console.error(err);
    alert('Search failed ‚Äì check the console or your API quota');
  }
});

/* ---------- init ---------- */
(async () => {
  loadQueue();
  await backfillArtists();          // <‚Äî new
  refreshSel();
  if (queue.length) playIdx(0);
})();
</script>
<script src="https://www.youtube.com/iframe_api"></script>
</body>
</html>